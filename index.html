<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Binary Search Tree</title>
<style>
body {
  font-family: Arial, sans-serif;
  background: linear-gradient(135deg, #4e73df, #1cc88a);
  text-align: center;
  margin: 0;
}

.container {
  background: white;
  width: 90%;
  max-width: 900px;
  margin: 40px auto;
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.2);
}

h1 {
  color: #4e73df;
}

input {
  padding: 8px;
  margin: 5px;
  border-radius: 8px;
  border: 1px solid #ccc;
}

button {
  padding: 8px 14px;
  margin: 5px;
  border: none;
  border-radius: 8px;
  background-color: #4e73df;
  color: white;
  cursor: pointer;
}

button:hover {
  background-color: #2e59d9;
}

canvas {
  margin-top: 20px;
  border-radius: 10px;
  background: #f8f9fc;
}
</style>
</head>

<body>
<div class="container">
  <h1>ðŸŒ³ Binary Search Tree (BST)</h1>

  <input type="number" id="value" placeholder="à¹ƒà¸ªà¹ˆà¸•à¸±à¸§à¹€à¸¥à¸‚">
  <button onclick="insertValue()">Insert</button>
  <button onclick="deleteValue()">Delete</button>
  <button onclick="displayTree()">Display</button>

  <canvas id="treeCanvas" width="800" height="400"></canvas>
</div>

<script>

class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.x = 0;
    this.y = 0;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return;
    }

    let current = this.root;
    while (true) {
      if (value < current.value) {
        if (!current.left) {
          current.left = newNode;
          return;
        }
        current = current.left;
      } else {
        if (!current.right) {
          current.right = newNode;
          return;
        }
        current = current.right;
      }
    }
  }

  deleteNode(node, value) {
    if (!node) return null;

    if (value < node.value) {
      node.left = this.deleteNode(node.left, value);
    } else if (value > node.value) {
      node.right = this.deleteNode(node.right, value);
    } else {
      if (!node.left && !node.right) return null;
      if (!node.left) return node.right;
      if (!node.right) return node.left;

      let min = node.right;
      while (min.left) min = min.left;
      node.value = min.value;
      node.right = this.deleteNode(node.right, min.value);
    }
    return node;
  }

  delete(value) {
    this.root = this.deleteNode(this.root, value);
  }
}

const tree = new BST();
const canvas = document.getElementById("treeCanvas");
const ctx = canvas.getContext("2d");

function insertValue() {
  const value = parseInt(document.getElementById("value").value);
  if (!isNaN(value)) {
    tree.insert(value);
    document.getElementById("value").value = "";
  }
}

function deleteValue() {
  const value = parseInt(document.getElementById("value").value);
  if (!isNaN(value)) {
    tree.delete(value);
    document.getElementById("value").value = "";
  }
}

function displayTree() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawTree(tree.root, canvas.width / 2, 40, canvas.width / 4);
}

function drawTree(node, x, y, offset) {
  if (!node) return;

  node.x = x;
  node.y = y;

  if (node.left) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - offset, y + 70);
    ctx.stroke();
    drawTree(node.left, x - offset, y + 70, offset / 2);
  }

  if (node.right) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + offset, y + 70);
    ctx.stroke();
    drawTree(node.right, x + offset, y + 70, offset / 2);
  }

  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2);
  ctx.fillStyle = "#4e73df";
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(node.value, x, y);
}

</script>
</body>
</html>
