<!DOCTYPE html>
<html>
<head>
  <title>Binary Search Tree</title>
</head>
<body>
  <h1>Binary Search Tree (BST)</h1>

  <input type="number" id="value" placeholder="ใส่ตัวเลข">
  <input type="number" id="newValue" placeholder="ค่าใหม่ (สำหรับ Update)">
  <br><br>

  <button onclick="insertValue()">Insert</button>
  <button onclick="deleteValue()">Delete</button>
  <button onclick="updateValue()">Update</button>
  <button onclick="displayTree()">Display</button>

  <h3>ผลลัพธ์:</h3>
  <pre id="output"></pre>

<script>

// ====== Node Class ======
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// ====== BST Class ======
class BST {
  constructor() {
    this.root = null;
  }

  // INSERT
  insert(value) {
    const newNode = new Node(value);

    if (this.root === null) {
      this.root = newNode;
      return;
    }

    let current = this.root;

    while (true) {
      if (value < current.value) {
        if (current.left === null) {
          current.left = newNode;
          return;
        }
        current = current.left;
      } else {
        if (current.right === null) {
          current.right = newNode;
          return;
        }
        current = current.right;
      }
    }
  }

  // FIND MIN (ใช้ตอนลบ)
  findMin(node) {
    while (node.left !== null) {
      node = node.left;
    }
    return node;
  }

  // DELETE
  deleteNode(node, value) {
    if (node === null) return null;

    if (value < node.value) {
      node.left = this.deleteNode(node.left, value);
    } else if (value > node.value) {
      node.right = this.deleteNode(node.right, value);
    } else {
      // ไม่มีลูก
      if (node.left === null && node.right === null) {
        return null;
      }

      // มีลูกข้างเดียว
      if (node.left === null) return node.right;
      if (node.right === null) return node.left;

      // มีลูกสองข้าง
      let minRight = this.findMin(node.right);
      node.value = minRight.value;
      node.right = this.deleteNode(node.right, minRight.value);
    }

    return node;
  }

  delete(value) {
    this.root = this.deleteNode(this.root, value);
  }

  // INORDER (แสดงเรียงจากน้อยไปมาก)
  inorder(node, result = []) {
    if (node !== null) {
      this.inorder(node.left, result);
      result.push(node.value);
      this.inorder(node.right, result);
    }
    return result;
  }

  // แสดงเป็นต้นไม้
  printTree(node, space = 0, result = []) {
    if (node === null) return;

    space += 5;

    this.printTree(node.right, space, result);

    result.push(" ".repeat(space - 5) + node.value);

    this.printTree(node.left, space, result);

    return result;
  }
}

// ====== ใช้งาน ======
const tree = new BST();

function insertValue() {
  const value = parseInt(document.getElementById("value").value);
  if (!isNaN(value)) {
    tree.insert(value);
    document.getElementById("value").value = "";
  }
}

function deleteValue() {
  const value = parseInt(document.getElementById("value").value);
  if (!isNaN(value)) {
    tree.delete(value);
    document.getElementById("value").value = "";
  }
}

function updateValue() {
  const oldValue = parseInt(document.getElementById("value").value);
  const newValue = parseInt(document.getElementById("newValue").value);

  if (!isNaN(oldValue) && !isNaN(newValue)) {
    tree.delete(oldValue);
    tree.insert(newValue);
    document.getElementById("value").value = "";
    document.getElementById("newValue").value = "";
  }
}

function displayTree() {
  let inorderResult = tree.inorder(tree.root).join(" ");
  let treeStructure = tree.printTree(tree.root).join("\n");

  document.getElementById("output").textContent =
    "เรียงลำดับ (Inorder):\n" + inorderResult +
    "\n\nโครงสร้างต้นไม้:\n\n" + treeStructure;
}

</script>
</body>
</html>
